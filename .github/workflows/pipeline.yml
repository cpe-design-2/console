name: Pipeline
on:
  push:

env:
  # the crate's name
  TARGET: goco # godoco? goko? gc? goconsole?
  # determine if to upload the executable as an artifact
  IS_LIB: false
  # the name of the compiled executable
  APP: goco
  # the path to the compiled executable
  APP_PATH: ./target/aarch64-unknown-linux-musl/release
  # compiler environment variables for cmake (freetype-sys crate)
  # CC: aarch64-linux-gnu-gcc
  # CXX: aarch64-linux-gnu-g++
  # PKG_CONFIG: aarch64-linux-gnu-pkg-config
  # PKG_CONFIG_PATH: /usr/lib/x86_64-linux-gnu/pkgconfig
  # TARGET_TRIPLE: aarch64-unknown-linux-musl
  # FONTCONFIG_DYNAMIC: 1

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Fetch repository
        uses: actions/checkout@v3

      - name: Configure RPi-OS
        uses: pguyot/arm-runner-action@v2
        id: build_image
        with: 
          base_image: raspios_lite:2022-04-04
          commands: |
            echo "hello world"

      - name: Configure Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable
          # install the target for the RPi3
          targets: ${{ env.TARGET_TRIPLE }}

      # - name: Install linker
      #   run: sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu pkg-config-aarch64-linux-gnu libfontconfig-dev fontconfig

      - name: Enable Cargo caching
        uses: Swatinem/rust-cache@v2

      # - name: Find fontconfig
      #   run: |
      #     sudo apt-get install apt-file
      #     sudo apt-file update
      #     sudo apt-file search fontconfig.pc

      # - name: Test
      #   run: cargo test # --target aarch64-unknown-linux-gnu

      - name: Build
        run: cargo build --release --target ${{ env.TARGET_TRIPLE }}

      - name: Package application
        if: env.IS_LIB == 'false'
        run: |
          # copy files and produce compressed archive for distribution
          import shutil, os
          target = '${{ env.TARGET }}-${{ github.ref_name }}'
          print(target)
          # create intermediate artifact directory
          os.makedirs(target)
          # copy the executable into the final directory
          shutil.copy2('${{ env.APP_PATH }}/${{ env.APP }}${{ matrix.ext }}', target+'/${{ env.APP }}${{ matrix.ext }}')
          # compress the final directory
          shutil.make_archive(target, 'zip', root_dir='.', base_dir=target)
        shell: python

      - name: Upload artifact
        if: env.IS_LIB == 'false'
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.TARGET }}-${{ github.ref_name }}
          path: ./${{ env.TARGET }}-${{ github.ref_name }}.zip
          if-no-files-found: error